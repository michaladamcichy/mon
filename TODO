FRONTEND
--------
poprawna obłsuga błędów w catchu





--------
BACKEND
--------
Docelowo wszystko robić na IDistancable??
    Robienie na MapObject i Group nie jest aż takie złe
    Natomiast Salesman już był świetny dzięki temu
Najprostszy najnaiwniejszy algorytm Greedy
Mój algorytm grupowania + łączenie Greedy
Mój algorytm grupowania + komiwojażer
Mój algorytm grupowania + wybór: tworzenie hubów/komiwojażer, także uwzględniając trójkąty
Przeglądanie wyłącznie trójkątami

MYŚLĘ, ŻE KURDE TRZEBABY ZAPEWNIĆ ZAWSZE KOMUNIKACJĘ W 2 STRONY MIĘDZY SĄSIADAMI
    ZAWSZE


CHOLIBKA - czy jednokierunkowa komunikacja cokolwiek daje? oprócz tego, 
    że w obrębie dużej stacji może być kilka małych?? 

WARIANT Z BEZPOŚREDNIMI POŁĄCZENIAMI piony - sztab i sztab - dywizje dowodzenia!

BYć może błąd nie wynika z niedokładności lat lng, lecz może powinienem dodatkowo sprawdzać, czy należą do okręgu

UWAGA - użyć klasy C# geolocation przy liczeniu odległości

A czy nie popełniasz takiego błędy, że bierzesz uśrednionen współrzedne zamiast faktycznego środka minimalnego
    okręgu opisującego?

Usunąłem tolerancję

ArrangeBetween - uwaga - dobierać ostatnią stację mniejszą, jeśli można

czyżby błąd z byciem poza zasięgiem się rozwiązał?
todo dawanie mniejszych stacji gdzie tylko możemy
łączenie stacji w obrębie grupy, o ile nie potrzeba dodatkowej stacji, powinno także przebiegać wg MST
alert duża wtopa Group.GetDistance(Station) może zwracać co innego niż Station.GetDistanceFrom(Group)

ALERT prosta optymalizacja - zaczynać algorytm najbliższego sąsiada od wierzchołka, który ma najmniejszą odległość
    do najbliższego sąsiada
ALERT ciągle nie wiem czy moje wyrafinowane grupowanie rzeczywiście robi to, co myślę

ALERT złagodzić sprawdzanie w IsConnected